################################################################################
# WeBWorK Online Homework Delivery System
# Copyright © 2000-2007 The WeBWorK Project, http://openwebwork.sf.net/
# $CVSHeader: webwork2/lib/WeBWorK/Utils/DelayedMailer.mail-sender.pm,v 1.1 2007/01/30 21:35:28 sh002i Exp $
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of either: (a) the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version, or (b) the "Artistic License" which comes with this package.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See either the GNU General Public License or the
# Artistic License for more details.
################################################################################

package WeBWorK::Utils::DelayedMailer;

use strict;
use warnings;
use Carp;
use Mail::Sender;
use Storable qw/dclone/;
use WeBWorK::Utils qw/constituency_hash/;

use constant SAFE_MAILMSG_PARAMS => qw/fake_from to fake_to cc fake_cc bcc subject msg/;

sub new {
	my ($invocant, %options) = @_;
	my $class = ref $invocant || $invocant;
	my $self = bless {}, $class;
	
	# messages get queued here. format: hashref, safe arguments to MailMsg
	$$self{msgs} = [];
	
	# options to pass to Mail::Sender::new
	$$self{new_opts} = $options{new_opts};
	
	# recipients are checked against this list before sending
	# these should be bare rfc822 addresses, not "Name <email@addr>"
	$$self{allowed_recipients} = constituency_hash(@{$options{allowed_recipients}});
	
	# what to do if an illegal recipient is specified
	# "croak" (default), "carp", or "ignore"
	$$self{on_illegal_rcpt} = $options{on_illegal_rcpt};
	
	# what to do if an unsafe argument is passed to add_message
	# "croak" (default), "carp", or "ignore"
	$$self{on_unsafe_arg} = $options{on_unsafe_arg};
	
	return $self;
}

sub add_message {
	my ($self, %msg) = @_;
	
	#warn "*** add_message: ", join(", ", map { "$_=>$msg{$_}" } keys %msg), "\n";
	
	my %safe_msg = $self->_check_fields(%msg);
	$safe_msg{to}  = $self->_check_recipients($safe_msg{to})  if defined $safe_msg{to};
	$safe_msg{cc}  = $self->_check_recipients($safe_msg{cc})  if defined $safe_msg{cc};
	$safe_msg{bcc} = $self->_check_recipients($safe_msg{bcc}) if defined $safe_msg{bcc};
	
	#warn "*** add_message: ", join(", ", map { "$_=>$safe_msg{$_}" } keys %safe_msg), "\n";
	
	push @{$$self{msgs}}, \%safe_msg;
}

sub _check_fields {
	my ($self, %msg) = @_;
	
	my %safe;
	foreach my $key (SAFE_MAILMSG_PARAMS) {
		$safe{$key} = $msg{$key} if exists $msg{$key};
		delete $msg{$key};
	}
	
	if (my @unsafe = keys %msg) {
		if (not defined $$self{on_unsafe_arg} or $$self{on_unsafe_arg} eq "croak") {
			die "unsafe fields '@unsafe'";
		} elsif ($$self{on_unsafe_arg} eq "carp") {
			warn "unsafe fields '@unsafe'";
		}
	}
	
	return %safe;
}

sub _check_recipients {
	my ($self, $rcpts) = @_;
	my @rcpts = ref $rcpts eq "ARRAY" ? @$rcpts : $rcpts;
	
	my @legal;
	foreach my $rcpt (@rcpts) {
		my ($base) = $rcpt =~ /<([^<>]*)>\s*$/; # works for addresses generated by Record::User
		$base ||= $rcpt; # if it doesn't match, it's a plain address
		if (exists $$self{allowed_recipients}{$base}) {
			push @legal, $rcpt;
		} else {
			if (not defined $$self{on_illegal_rcpt} or $$self{on_illegal_rcpt} eq "croak") {
				die "can't address message to illegal recipient '$rcpt'";
			} elsif ($$self{on_illegal_rcpt} eq "carp") {
				warn "can't address message to illegal recipient '$rcpt'";
			}
		}
	}
	
	return @legal;
}

sub send_messages {
	my ($self) = @_;
	
	#warn "*** send_messages called! there are ", scalar @{$$self{msgs}}, " messages to send.\n";
	#return;
	return unless @{$$self{msgs}};
	
	my $mailer = new Mail::Sender {
		keepconnection => 1,
		skip_bad_recipients => 1,
		%{$$self{new_opts}},
	};
	ref $mailer or die $Mail::Sender::Error;
	
	my @results;
	foreach my $msg (@{$$self{msgs}}) {
		push @results, _send_msg($mailer, $msg);
	}
}

# return format:
#   success => true if all succeeded (no need for error reporting)
#   error => Mail::Sender error code
#   error_msg => Mail::Sender error message
#   skipped_recipients => Mail::Sender skipped_recipients hash
sub _send_msg {
	my ($mailer, $msg) = @_;
	
	my %result;
	my $ret = $mailer->MailMsg($msg);
	if (ref $ret) {
		if (defined $mailer->{skipped_recipients}) {
			$result{skipped_recipients} = $mailer->{skipped_recipients};
		} else {
			$result{success} = 1;
		}	
	} else {
		$result{error} = $mailer->{error};
		$result{error_msg} = $mailer->{error_msg};
	}
	
	return \%result;
}

1;
