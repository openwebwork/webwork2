#!/usr/bin/env perl
################################################################################
# WeBWorK Online Homework Delivery System
# Copyright © 2000-2006 The WeBWorK Project, http://openwebwork.sf.net/
# $CVSHeader: webwork2/bin/wwdb,v 1.13 2006/01/25 23:13:45 sh002i Exp $
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of either: (a) the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version, or (b) the "Artistic License" which comes with this package.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See either the GNU General Public License or the
# Artistic License for more details.
################################################################################

=head1 NAME

wwdb_check - check the schema of an existing WeBWorK database

=head1 SYNOPSIS

 wwdb_check [-v] [ COURSE ... ]

=head1 DESCRIPTION

Scans an existing WeBWorK database to verify that its structure is correct. If
no courses are listed on the command line, all courses are checked. Checks for
the following:

=over

=item *

Make sure that the appropriate tables exist for each course.

=item *

Make sure that the proper columns exist in each table.

=item *

Verify that the proper column type is in use for each column.

=back

=head1 OPTIONS

=over

=item -v

Verbose output

=back

=cut

use strict;
use warnings;
use Getopt::Std;
use DBI;
use Data::Dumper;

BEGIN {
	die "WEBWORK_ROOT not found in environment.\n"
		unless exists $ENV{WEBWORK_ROOT};
}

use lib "$ENV{WEBWORK_ROOT}/lib";
use WeBWorK::CourseEnvironment;
use WeBWorK::Utils qw/runtime_use/;
use WeBWorK::Utils::CourseManagement qw/listCourses/;

our $opt_v;
getopts("v");

if ($opt_v) {
	$| = 1;
	*verbose = sub { print STDERR @_ };
} else {
	*verbose = sub {};
}

# a random coursename we can grab back out later
my @chars = ('A'..'Z','a'..'z','0'..'9');
my $random_courseID = join("", map { $chars[rand(@chars)] } 1..16);

my $ce = WeBWorK::CourseEnvironment->new({
	webwork_dir => $ENV{WEBWORK_ROOT},
	courseName => $random_courseID,
});

my $dbh = DBI->connect(
	$ce->{database_dsn},
	$ce->{database_username},
	$ce->{database_password},
	{
		RaiseError => 1,
	},
);

=for comment

 %ww_table_data = (
	 $table => {
		 sql_name => "SQL name for this field, probably contains $random_courseID",
		 fields => {
			 $field => {
				 sql_name => "SQL name for this field, possibly overridden",
				 sql_type => "type for this field, from SQL_TYPES in record class",
				 is_keyfield => "boolean, whether or not this field is a keyfield",
			 },
			 ...
		 },
	 },
	 ...
 );

=cut

my %ww_table_data = get_ww_table_data();

my %sql_tables = get_sql_tables();

# FIXME we now need to not SHOW TABLES and just use the fake courseID value and
# s/// to test for each table
# FIXME then change the rest of the code to use the new ww_table_data format
# change the name of the variable

my @ww_courses = @ARGV;
@ww_courses = listCourses($ce) if not @ww_courses;

foreach my $ww_course_name (@ww_courses) {
	verbose("\nChecking tables for course '$ww_course_name'\n");
	
	foreach my $ww_table_name (keys %ww_table_data) {
		check_table($ww_course_name, $ww_table_name);
	}
}

exit;

################################################################################

sub get_ww_table_data {
	my %result;
	
	foreach my $table (keys %{$ce->{dbLayout}}) {
		my $record_class = $ce->{dbLayout}{$table}{record};
		runtime_use $record_class;
		
		my @fields = $record_class->FIELDS;
		my @types = $record_class->SQL_TYPES;
		my @keyfields = $record_class->KEYFIELDS;
		my %keyfields; @keyfields{@keyfields} = ();
		
		my %field_data;
		
		foreach my $i (0..$#fields) {
			my $field = $fields[$i];
			my $field_sql = $ce->{dbLayout}{$table}{params}{fieldOverride}{$field};
			$field_data{$field}{sql_name} = $field_sql || $field;
			
			my $type = $types[$i];
			$field_data{$field}{sql_type} = $type;
			
			$field_data{$field}{is_keyfield} = exists $keyfields{$field};
		}
		
		$result{$table}{fields} = \%field_data;
		$result{$table}{field_order} = \@fields;
		$result{$table}{keyfield_order} = \@keyfields;
		
		my $table_sql = $ce->{dbLayout}{$table}{params}{tableOverride};
		$result{$table}{sql_name} = $table_sql || $table;
	}
	
	return %result;
}

sub get_sql_tables {
	my $sql_tables_ref = $dbh->selectcol_arrayref("SHOW TABLES");
	my %sql_tables; @sql_tables{@$sql_tables_ref} = ();
	
	return %sql_tables;
}

################################################################################

sub check_table {
	my ($ww_course_name, $ww_table_name) = @_;
	my $sql_table_name = get_sql_table_name($ww_table_data{$ww_table_name}{sql_name}, $ww_course_name);
	
	verbose("\nChecking '$ww_table_name' table (SQL table '$sql_table_name')\n");
	
	if (exists $sql_tables{$sql_table_name}) {
		check_fields($ww_course_name, $ww_table_name, $sql_table_name);
		delete $sql_tables{$sql_table_name};
	} else {
		print "$sql_table_name: table missing\n";
		my $ww_table_rec = $ww_table_data{$ww_table_name};
		if (maybe_add_table($ww_course_name, $ww_table_name)) {
			check_fields($ww_course_name, $ww_table_name, $sql_table_name);
			delete $sql_tables{$sql_table_name};
		}
	}
}

sub maybe_add_table {
	my ($ww_course_name, $ww_table_name) = @_;
	my $ww_table_rec = $ww_table_data{$ww_table_name};
	my $sql_table_name = get_sql_table_name($ww_table_rec->{sql_name}, $ww_course_name);
	
	my $stmt = create_table_stmt($ww_table_rec, $sql_table_name);
	
	print "\nI can add this table to the database with the following SQL statement:\n\n";
	print "$stmt\n\n";
	print "If this is an upgraded installation, it is possible that '$ww_course_name' is an old GDBM course. (This utility is too lazy to check.) If this is the case, you should probably not add this table, as it won't be used.\n";
	return 0 unless ask_permission("Add table '$sql_table_name'?");
	
	$dbh->do($stmt); # relying on RaiseError here...
	print "Added table '$sql_table_name'.\n\n";
	
	return 1;
}

sub create_table_stmt {
	my ($ww_table_rec, $sql_table_name) = @_;
	
	#print Dumper($ww_table_rec);
	
	my @field_list;
	
	# generate a column specification for each field
	my @fields = @{$ww_table_rec->{field_order}};
	foreach my $field (@fields) {
		my $ww_field_rec = $ww_table_rec->{fields}{$field};
		my $sql_field_name = $ww_field_rec->{sql_name};
		my $sql_field_type = $ww_field_rec->{sql_type};
		
		push @field_list, "`$sql_field_name` $sql_field_type";
	}
	
	# generate an INDEX specification for each all possible sets of keyfields (i.e. 0+1+2, 1+2, 2)
	my @keyfields = @{$ww_table_rec->{keyfield_order}};
	foreach my $start (0 .. $#keyfields) {
		my @index_components;
		
		foreach my $component (@keyfields[$start .. $#keyfields]) {
			my $ww_field_rec = $ww_table_rec->{fields}{$component};
			my $sql_field_name = $ww_field_rec->{sql_name};
			my $sql_field_type = $ww_field_rec->{sql_type};
			my $length_specifier = ($sql_field_type =~ /int/i) ? "" : "(16)";
			push @index_components, "`$sql_field_name`$length_specifier";
		}
		
		my $index_string = join(", ", @index_components);
		push @field_list, "INDEX ( $index_string )";
	}
	
	my $field_string = join(", ", @field_list);
	my $create_stmt = "CREATE TABLE `$sql_table_name` ( $field_string )";
	
	return $create_stmt;
}

################################################################################

sub check_fields {
	my ($ww_course_name, $ww_table_name, $sql_table_name) = @_;
	
	my $describe_data = $dbh->selectall_hashref("DESCRIBE `$sql_table_name`", 1);
	
	foreach my $ww_field_name (@{$ww_table_data{$ww_table_name}{field_order}}) {
		my $ww_field_rec = $ww_table_data{$ww_table_name}{fields}{$ww_field_name};
		my $sql_field_name = $ww_field_rec->{sql_name};
		my $sql_field_rec = $describe_data->{$sql_field_name};
		
		verbose("Checking '$ww_field_name' field (SQL field '$sql_table_name.$sql_field_name')\n");
		
		#print "$sql_table_name.$sql_field_name:\n";
		#print Dumper($ww_field_rec);
		#print Dumper($sql_field_rec);
		
		if (defined $sql_field_rec) {
			my ($sql_base_type) = $sql_field_rec->{Type} =~ /^([^(]*)/;
			#print $sql_field_rec->{Type}, " => $sql_base_type\n";
			
			my $needs_fixing = 0;
			if ($ww_field_name eq "psvn") {
				
				unless ("int" eq lc($sql_base_type)) {
					$needs_fixing = 1;
					print "$sql_table_name.$sql_field_name: type should be 'int' but appears to be '",
						 lc($sql_base_type), "'\n";
				}
				
				unless (lc($sql_field_rec->{Extra}) =~ /\bauto_increment\b/) {
					$needs_fixing = 1;
					print "$sql_table_name.$sql_field_name: extra should contain 'auto_increment' but appears to be '",
						lc($sql_field_rec->{Extra}), "'\n";
				}
				
				# FIXME instead of checking this, figure out how to use "SHOW INDEXES FROM `$sql_table_name`"
				#unless ("pri" eq lc($sql_field_rec->{Key})) {
				#	$needs_fixing = 1;
				#	print "$sql_table_name.$sql_field_name: key should be 'pri' but appears to be '",
				#		lc($sql_field_rec->{Key}), "'\n";
				#}
				
			} else {
				
				unless (lc($ww_field_rec->{sql_type}) eq lc($sql_base_type)) {
					$needs_fixing = 1;
					print "$sql_table_name.$sql_field_name: type should be '", lc($ww_field_rec->{sql_type}),
						"' but appears to be '", lc($sql_base_type), "'\n";
				}
				
				# FIXME instead of checking this, figure out how to use "SHOW INDEXES FROM `$sql_table_name`"
				#unless ( $ww_field_rec->{is_keyfield} == (lc($sql_field_rec->{Key}) eq "mul") ) {
				#	$needs_fixing = 1;
				#	print "$sql_table_name.$sql_field_name: key should be '",
				#		($ww_field_rec->{is_keyfield} ? "mul" : ""), "' but appears to be '",
				#		lc($sql_field_rec->{Key}), "'\n";
				#}
			}
			
			$needs_fixing and maybe_change_field($ww_course_name, $ww_table_name, $ww_field_name);
			
		} else {
			print "$sql_table_name.$sql_field_name: field missing\n";
			maybe_add_field($ww_course_name, $ww_table_name, $ww_field_name);
		}
	}
}

sub maybe_add_field {
	my ($ww_course_name, $ww_table_name, $ww_field_name) = @_;
	my $ww_table_rec = $ww_table_data{$ww_table_name};
	my $sql_table_name = get_sql_table_name($ww_table_rec->{sql_name}, $ww_course_name);
	my $sql_field_name = $ww_table_rec->{fields}{$ww_field_name}{sql_name};
	
	my $stmt = add_field_stmt($ww_table_rec, $ww_field_name, $sql_table_name);
	
	print "\nI can add this field to the database with the following SQL statement:\n\n";
	print "$stmt\n\n";
	return 0 unless ask_permission("Add field '$sql_table_name.$sql_field_name'?");
	
	$dbh->do($stmt); # relying on RaiseError here...
	print "Added field '$sql_field_name'.\n\n";
	
	return 0;
}

sub add_field_stmt {
	my ($ww_table_rec, $ww_field_name, $sql_table_name) = @_;
	my $sql_field_name = $ww_table_rec->{fields}{$ww_field_name}{sql_name};
	my $sql_field_type = $ww_table_rec->{fields}{$ww_field_name}{sql_type};
	my $location_modifier = get_location_modifier($ww_table_rec, $ww_field_name);
	
	return "ALTER TABLE `$sql_table_name` ADD COLUMN `$sql_field_name` $sql_field_type $location_modifier";
}

sub get_location_modifier {
	my ($ww_table_rec, $ww_field_name) = @_;
	
	my $field_index = -1;
	
	for (my $i = 0; $i < @{$ww_table_rec->{field_order}}; $i++) {
		if ($ww_table_rec->{field_order}[$i] eq $ww_field_name) {
			$field_index = $i;
			last;
		}
	}
	
	if ($field_index < 0) {
		die "field '$ww_field_name' not found in field_order (shouldn't happen!)";
	} elsif ($field_index > 0) {
		my $ww_prev_field_name = $ww_table_rec->{field_order}[$field_index-1];
		my $sql_prev_field_name = $ww_table_rec->{fields}{$ww_prev_field_name}{sql_name};
		return "AFTER `$sql_prev_field_name`";
	} else {
		return "FIRST";
	}
}

sub maybe_change_field {
	my ($ww_course_name, $ww_table_name, $ww_field_name) = @_;
	my $ww_table_rec = $ww_table_data{$ww_table_name};
	my $sql_table_name = get_sql_table_name($ww_table_rec->{sql_name}, $ww_course_name);
	my $sql_field_name = $ww_table_rec->{fields}{$ww_field_name}{sql_name};
	
	my $stmt = change_field_stmt($ww_table_rec, $ww_field_name, $sql_table_name);
	
	print "\nI can change this field with the following SQL statement:\n\n";
	print "$stmt\n\n";
	return 0 unless ask_permission("Change field '$sql_table_name.$sql_field_name'?");
	
	$dbh->do($stmt); # relying on RaiseError here...
	print "Changed field '$sql_field_name'.\n\n";
	
	return 0;
}

sub change_field_stmt {
	my ($ww_table_rec, $ww_field_name, $sql_table_name) = @_;
	my $sql_field_name = $ww_table_rec->{fields}{$ww_field_name}{sql_name};
	my $sql_field_type = $ww_table_rec->{fields}{$ww_field_name}{sql_type};
	
	return "ALTER TABLE `$sql_table_name` CHANGE COLUMN `$sql_field_name` `$sql_field_name` $sql_field_type";
}

################################################################################

sub get_sql_table_name {
	my ($template, $course_name) = @_;
	
	$template =~ s/$random_courseID/$course_name/g;
	return $template;
}

sub ask_permission {
	my ($prompt, $default) = @_;
	
	$default = 1 if not defined $default;
	my $options = $default ? "[Y/n]" : "[y/N]";
	
	while (1) {
		print "$prompt $options ";
		my $resp = <STDIN>;
		chomp $resp;
		return $default if $resp eq "";
		return 1 if lc $resp eq "y";
		return 0 if lc $resp eq "n";
		$prompt = 'Please enter "y" or "n".';
	}
}

################################################################################
# FIXME FIXME FIXME this code is stolen from CourseManagement::sql_single and
# you really need to merge it back in before things get crazy FIXME FIXME FIXME
################################################################################
# (i actually like this method better, since we have a nice $sql_table_rec
# structure that keeps us from having to do manual checking of override fields)

