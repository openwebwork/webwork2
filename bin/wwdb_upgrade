#!/usr/bin/env perl
################################################################################
# WeBWorK Online Homework Delivery System
# Copyright © 2000-2006 The WeBWorK Project, http://openwebwork.sf.net/
# $CVSHeader: webwork2/bin/wwdb_upgrade,v 1.5 2006/09/28 23:42:27 sh002i Exp $
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of either: (a) the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version, or (b) the "Artistic License" which comes with this package.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See either the GNU General Public License or the
# Artistic License for more details.
################################################################################

use strict;
use warnings;
use Getopt::Std;
use DBI;
use Data::Dumper;

BEGIN {
	die "WEBWORK_ROOT not found in environment.\n"
		unless exists $ENV{WEBWORK_ROOT};
}

use lib "$ENV{WEBWORK_ROOT}/lib";
use WeBWorK::CourseEnvironment;
use WeBWorK::Utils qw/runtime_use/;
use WeBWorK::Utils::CourseManagement qw/listCourses/;

our ($opt_v);
getopts("v");

if ($opt_v) {
	$| = 1;
	*verbose = sub { print STDERR @_ };
} else {
	*verbose = sub {};
}

# global variables, hah hah.
my ($dbh, %sql_tables);

################################################################################

our $THIS_DB_VERSION = 6;

our @DB_VERSIONS;

$DB_VERSIONS[0]{desc} = "is the initial version of database, identical to database structure in WeBWorK 2.2.x.";

$DB_VERSIONS[1]{desc} = "adds dbupgrade table to facilitate automatic database upgrades.";
$DB_VERSIONS[1]{global_code} = sub {
	$dbh->do("CREATE TABLE `dbupgrade` (`name` VARCHAR(255) NOT NULL PRIMARY KEY, `value` TEXT)");
	$dbh->do("INSERT INTO `dbupgrade` (`name`, `value`) VALUES (?, ?)", {}, "db_version", 1);
	$sql_tables{dbupgrade} = ();
};

$DB_VERSIONS[2]{desc} = "adds problems_per_page field to set and set_user tables of each course.";
$DB_VERSIONS[2]{course_code} = sub {
	my $course = shift;
	$dbh->do("ALTER TABLE `${course}_set` ADD COLUMN `problems_per_page` INT")
		if exists $sql_tables{"${course}_set"};
	$dbh->do("ALTER TABLE `${course}_set_user` ADD COLUMN `problems_per_page` INT")
		if exists $sql_tables{"${course}_set_user"};
};

$DB_VERSIONS[3]{desc} = "adds depths table to keep track of dvipng depth information.";
$DB_VERSIONS[3]{global_code} = sub {
	$dbh->do("CREATE TABLE depths (md5 CHAR(33) NOT NULL, depth SMALLINT, PRIMARY KEY (md5))");
	$sql_tables{depths} = ();
};

$DB_VERSIONS[4]{desc} = "changes type of key timestamp field to BIGINT";
$DB_VERSIONS[4]{course_code} = sub {
	my $course = shift;
	return unless exists $sql_tables{"${course}_key"};
	$dbh->do("ALTER TABLE `${course}_key` CHANGE COLUMN `timestamp` `timestamp` BIGINT");
};

$DB_VERSIONS[5]{desc} = "changes type of problem_user status field to FLOAT";
$DB_VERSIONS[5]{course_code} = sub {
	my $course = shift;
	return unless exists $sql_tables{"${course}_problem_user"};
	$dbh->do("UPDATE `${course}_problem_user` SET `status`=NULL WHERE `status`=''");
	$dbh->do("ALTER TABLE `${course}_problem_user` CHANGE COLUMN `status` `status` FLOAT");
};

$DB_VERSIONS[6]{desc} = "changes types of alphanumeric keyfields to TINYBLOB NOT NULL";
$DB_VERSIONS[6]{course_code} = sub {
	my $course = shift;
	$dbh->do("ALTER TABLE `${course}_user` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_user"};
	$dbh->do("ALTER TABLE `${course}_password` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_password"};
	$dbh->do("ALTER TABLE `${course}_permission` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_permission"};
	$dbh->do("ALTER TABLE `${course}_key` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_key"};
	$dbh->do("ALTER TABLE `${course}_set` CHANGE COLUMN `set_id` `set_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_set"};
	$dbh->do("ALTER TABLE `${course}_problem` CHANGE COLUMN `set_id` `set_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_problem"};
	$dbh->do("ALTER TABLE `${course}_set_user` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_set_user"};
	$dbh->do("ALTER TABLE `${course}_set_user` CHANGE COLUMN `set_id` `set_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_set_user"};
	$dbh->do("ALTER TABLE `${course}_problem_user` CHANGE COLUMN `user_id` `user_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_problem_user"};
	$dbh->do("ALTER TABLE `${course}_problem_user` CHANGE COLUMN `set_id` `set_id` TINYBLOB NOT NULL")
		if exists $sql_tables{"${course}_problem_user"};
};

################################################################################

my $ce = WeBWorK::CourseEnvironment->new({
	webwork_dir => $ENV{WEBWORK_ROOT},
});

my @ww_courses = listCourses($ce);

$dbh = DBI->connect(
	$ce->{database_dsn},
	$ce->{database_username},
	$ce->{database_password},
	{
		PrintError => 0,
		RaiseError => 1,
	},
);

{
	verbose("Obtaining dbupgrade lock...\n");
	my ($lock_status) = $dbh->selectrow_array("SELECT GET_LOCK('dbupgrade', 10)");
	if (not defined $lock_status) {
		print "Couldn't obtain lock because an error occurred.\n";
		exit 2;
	}
	if ($lock_status) {
		verbose("Got lock.\n");
	} else {
		print "Timed out while waiting for lock.\n";
		exit 2;
	}
}

%sql_tables = get_sql_tables();

my $db_version = exists $sql_tables{dbupgrade} ? get_db_version() : 0;

if (not defined $db_version) {
	print "Failed to get db_version -- can't continue.\n";
	exit 1;
}

verbose("Initial db_version is $db_version\n");

if ($db_version > $THIS_DB_VERSION) {
	print "db_version is $db_version, but the current database version is only $THIS_DB_VERSION. This database was probably used with a newer version of WeBWorK.\n";
	exit;
}

while ($db_version < $THIS_DB_VERSION) {
	$db_version++;
	unless (upgrade_to_version($db_version)) {
		print "\nUpgrading from version ".($db_version-1)." to $db_version failed.\n\n";
		unless (ask_permission("Ignore this error and go on to the next version?", 0)) {
			exit 3;
		}
	}
	set_db_version($db_version);
}

print "\nDatabase is up-to-date at version $db_version.\n";

END {
	verbose("Releasing dbupgrade lock...\n");
	my ($lock_status) = $dbh->selectrow_array("SELECT RELEASE_LOCK('dbupgrade')");
	if (not defined $lock_status) {
		print "Couldn't release lock because the lock does not exist.\n";
		exit 2;
	}
	if ($lock_status) {
		verbose("Released lock.\n");
	} else {
		print "Couldn't release lock because the lock is not held by this thread.\n";
		exit 2;
	}
}

################################################################################

sub get_sql_tables {
	my $sql_tables_ref = $dbh->selectcol_arrayref("SHOW TABLES");
	my %sql_tables; @sql_tables{@$sql_tables_ref} = ();
	
	return %sql_tables;
}

sub get_db_version {
	my $vers_value_should_be = "This value should always be a positive integer.";
	my $vers_stop_now = "You should stop now and take a closer look.";
	
	my @record = $dbh->selectrow_array("SELECT `value` FROM `dbupgrade` WHERE `name`='db_version'");
	if (@record) {
		my $db_version = $record[0];
		if (not defined $db_version) {
			print "'db_version' exists, but it has a NULL value. $vers_value_should_be $vers_stop_now\n";
			return;
		} elsif ($db_version !~ /^-?\d+$/) {
			print "'db_version' is set to the non-numeric value '$db_version'. $vers_value_should_be $vers_stop_now\n";
			return;
		} elsif ($db_version < 0) {
			print "'db_version' is set to the negative value '$db_version'. $vers_value_should_be $vers_stop_now\n";
			return;
		} elsif ($db_version == 0) {
			print "'db_version' is set 0, which is reserved to indicate a pre-automatic-upgrade version. $vers_value_should_be $vers_stop_now\n";
			return;
		} else {
			# db_version is positive! yay!
			return $db_version;
		}
	} else {
		print "The 'dbupgrade' table exists, but doesn't contain a 'db_version' setting. $vers_stop_now\n";
		return;
	}
}

sub set_db_version {
	my $vers = shift;
	$dbh->do("UPDATE `dbupgrade` SET `value`=? WHERE `name`='db_version'", {}, $vers);
}

sub upgrade_to_version {
	my $vers = shift;
	my %info = %{$DB_VERSIONS[$vers]};
	
	print "\nUpgrading database from version " . ($vers-1) . " to $vers...\n";
	my $desc = $info{desc} || "has no description.";
	print "(Version $vers $desc)\n";
	
	if (exists $info{global_code}) {
		eval { $info{global_code}->() };
		if ($@) {
			print "\nAn error occured while running the system upgrade code for version $vers:\n";
			print "$@";
			return 0 unless ask_permission("Ignore this error and keep going?", 0);
		}
	}
	
	if (@ww_courses and exists $info{course_code}) {
		foreach my $curr_course (@ww_courses) {
			eval { $info{course_code}->($curr_course) };
			if ($@) {
				print "\nAn error occured while running the course upgrade code for version $vers on course $curr_course:\n";
				print "$@";
				next if ask_permission("Ignore this error and go on to the next course?", 0);
			}
		}
	}
	
	print "Done.\n";
	return 1;
}

################################################################################

sub ask_permission {
	my ($prompt, $default) = @_;
	
	$default = 1 if not defined $default;
	my $options = $default ? "[Y/n]" : "[y/N]";
	
	while (1) {
		print "$prompt $options ";
		my $resp = <STDIN>;
		chomp $resp;
		return $default if $resp eq "";
		return 1 if lc $resp eq "y";
		return 0 if lc $resp eq "n";
		$prompt = 'Please enter "y" or "n".';
	}
}
