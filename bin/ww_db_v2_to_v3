#!/usr/bin/env perl
################################################################################
# WeBWorK Online Homework Delivery System
# Copyright © 2000-2003 The WeBWorK Project, http://openwebwork.sf.net/
# $CVSHeader: webwork2/bin/ww_db_v2_to_v3,v 1.1 2004/11/25 05:50:51 sh002i Exp $
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of either: (a) the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version, or (b) the "Artistic License" which comes with this package.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See either the GNU General Public License or the
# Artistic License for more details.
################################################################################

=head1 NAME

ww_db_v2_to_v3 - convert a WWDBv2 database to a WWDBv3 database.

=head1 SYNOPSIS

 ww_db_v2_to_v3 -crsuv course ...

=head1 DESCRIPTION

Copies course data from legacy WWDBv2 database(s) to a WWDBv3 database. This may
take a long time.

You must disallow login to the WeBWorK system while the transfer is taking
place. To disable logins for all courses, set the permission level necessary for
C<login> to $nobody in F<global.conf>. (It is usually set to $student.)

=head1 OPTIONS

=over

=item -c

If an error occurs while copying a course's data, continue copying with the next
course.

=item -r

Update role table in WWDBv3 database from permission level information in
F<global.conf>.

=item -s

Update status table in WWDBv3 database from the status information in
F<global.conf>.

=item -u

When importing a user that already exists in the WWDBv3 database, replace the
existing information (including the password) with the information in the user
record being imported.

If this option is not specified, existing users are not updated.

=item -v

Verbose operation.

=item course ...

Data from these courses will be copied.

=back

=head1 BEHAVIOR

=head2 ROLES

=over

=item *

Roles created with the -r switch are created as system-wide roles.

=item *

Roles are created by observing the %permissionLevels hash in F<global.conf>, and
collecting the privileges granted at each permission level into sets. Each set
of privileges becomes a WWDBv3 role record.

=item *

When a role with the same set of permissions already exists in the WWDBv3
database, a new one is not created.

=back

=head2 STATUSES

=over

=item *

Statuses created with the -s switch are created as system-wide statuses.

=item *

Statuses are created by observing the %{$siteDefaults{status}} hash in
F<global.conf>, and 

=item *

A status named "Enrolled" is imported into the database with the
C<allow_course_access>, C<include_in_assignment>, C<include_in_stats>, and
C<include_in_scoring> flags set.

=item *

A status named "Audit" is imported into the database with the
C<allow_course_access>, C<include_in_assignment>, and C<include_in_stats>, flags
set, and the C<include_in_scoring> flag unset.

=item *

A status named "Drop" is imported into the database with the
C<allow_course_access>, C<include_in_assignment>, C<include_in_stats>, and
C<include_in_scoring> flags unset.

=item *

Statuses with other names are imported into the database with the same flags set
as the "Enrolled" flag.

=back

=head2 USERS

=over

=item *

WWDBv2 user IDs are converted to login IDs.

=item *

Users with the same v2 user ID in different courses are assumed to be the same
user.

=item *

A user's permission level is used to determine the role to assign to their v3
participant record. (See L<ROLES>.) If the user has an empty permission level,
they are assigned the role associated with permission level "0".

=item *

A user's status abbreviation is used to determine the status to assign to their
v3 participant record. (See L<STATUSES>.) If the user has an empty status, they
are assigned the status "Enrolled".

=item *

If a user has a non-empty section or recitation, their v3 participant record
will be assigned to the section or recitation with a matching name.

=back

=cut

use strict;
use warnings;
use Data::Dumper;
use DateTime;
use Getopt::Std;

BEGIN {
	die "WEBWORK_ROOT not found in environment.\n"
		unless exists $ENV{WEBWORK_ROOT};
}

use lib "$ENV{WEBWORK_ROOT}/lib";
use WeBWorK::CourseEnvironment;
use WeBWorK::DB;
use WeBWorK::DBv3;

# map statuses from course environment to sets of status privileges
use constant STATUS_MAP => {
	Enrolled => { allow_course_access => 1, include_in_assignment => 1, include_in_stats => 1, include_in_scoring => 1 },
	Audit    => { allow_course_access => 1, include_in_assignment => 1, include_in_stats => 1, include_in_scoring => 0 },
	Drop     => { allow_course_access => 0, include_in_assignment => 0, include_in_stats => 0, include_in_scoring => 0 },
};

use constant DEFAULT_STATUS => "C";
use constant DEFAULT_PERMISSION_LEVEL => "0";

our ($opt_c, $opt_r, $opt_s, $opt_u, $opt_v);
getopts("crsuv");

sub debug { print STDERR @_ if $opt_v }
sub usage { print STDERR "usage: $0 [-crsuv] course ...\n"; exit 1 }

main(@ARGV);

sub main {
	my (@courseIDs) = @_;
	
	usage() unless @courseIDs;
	
	my $ce = WeBWorK::CourseEnvironment->new({webwork_dir => $ENV{WEBWORK_ROOT}});
	
	WeBWorK::DBv3::init($ce->{wwdbv3_settings});
	
	my %abbrev_to_status_id = set_up_statuses($ce->{siteDefaults}{status});
	warn "abbrev_to_status_id: ", Dumper(\%abbrev_to_status_id);
	
	my %level_to_role_id = set_up_roles($ce->{permissionLevels});
	warn "level_to_role_id: ", Dumper(\%level_to_role_id);
	
	foreach my $courseID (@courseIDs) {
		eval { copy_course_data($courseID, \%abbrev_to_status_id, \%level_to_role_id) };
		if ($@) {
			warn "An error occured while copying data from course '$courseID':\n\n$@\n\n";
			if ($opt_c) {
				warn "Continuing with the next course...\n";
			} else {
				warn "Exiting.\n";
				exit 2;
			}
		}
	}
}

################################################################################

sub reverse_hash {
	my (%hash) = @_;
	
	my %reverse_hash;
	foreach my $key (keys %hash) {
		my $value = $hash{$key};
		if (defined $value and not ref $value) {
			push @{ $reverse_hash{$value} }, $key;
		#} else {
		#	my $val_string = defined $value ? $value : "UNDEF";
		#	warn "pair ( $key => $val_string ) skipped.\n";
		}
	}
	
	return %reverse_hash;
}

sub listeq {
	my ($a, $b) = @_;
	return "" unless @$a == @$b;
	for (my $i = 0; $i < @$a; $i++) {
		return "" unless $a->[$i] eq $b->[$i];
	}
	return 1;
}

sub is_empty {
	my ($val) = @_;
	return (not defined $val or $val eq "");
}

################################################################################

sub set_up_roles {
	my ($permissionLevels) = @_;
	my %permissionLevels = %$permissionLevels;
	
	my %level_to_role_id;
	
	# reverse the permission levels hash, resulting in a hash mapping
	# permissions levels to arrayrefs containing privileges
	my %levels = reverse_hash(%permissionLevels);
	
	# copy up the privileges at each level to the next-higher level
 	# also sort each level
	my @level_names = sort { $a <=> $b } keys %levels;
	foreach my $i (0 .. $#level_names-1) {
		my $this_level = $level_names[$i];
		my $next_level = $level_names[$i+1];
		push @{ $levels{$next_level} }, @{ $levels{$this_level} };
	}
	
	# sort the privileges in each level
	debug("I found the following permission levels:\n");
	foreach my $level (keys %levels) {
		my @sorted = sort @{ $levels{$level} };
		$levels{$level} = [ @sorted ];
		debug("\t$level => @sorted\n");
	}
	
	# keep track of role names so we know if we need to rename any of our new ones
	my %role_names;
	
	# look at existing roles to see if we can avoid adding some new ones
	my $i = retrieve_all WeBWorK::DBv3::Role;
	while (my $Role = $i->next) {
		$role_names{$Role->name} = 1;
		my @role_privs = sort $Role->priv_list;
		
		foreach my $level (keys %levels) {
			if (listeq($levels{$level}, \@role_privs)) {
				debug("Permission level '$level' is already represented as role '",
					$Role->name, "' (ID $Role) -- skipping.\n");
				delete $levels{$level};
				$level_to_role_id{$level} = $Role->id;
			}
		}
	}
	
	if ($opt_r) {
		debug("Updating role table (as per -r switch).\n");
		foreach my $level (keys %levels) {
			my $name = "Legacy permission level $level";
			if (exists $role_names{$name}) {
				my $i = 2;
				while (1) {
					my $try_name = "$name (#$i)";
					if (not exists $role_names{$try_name}) {
						$name = $try_name;
						last;
					}
				}
			}
			
			my @privs = @{ $levels{$level} };
			
			my $Role = create WeBWorK::DBv3::Role({name => $name });
			$Role->priv_list(@privs);
			$Role->update;
			debug("Added role '", $Role->name, "' (ID $Role) with privileges '@privs'.\n");
			$level_to_role_id{$level} = $Role->id;
		}
	} else {
		debug("Not updating role table (as per lack of -r switch).\n");
		debug("I might run into users with permission levels that don't map to roles later.\n");
	}
	
	return %level_to_role_id;
}

sub set_up_statuses {
	my ($abbrevs) = @_;
	my %abbrevs = %$abbrevs;
	
	my %abbrev_to_status_id;
	
	# reverse the statuses hash, resulting in a hash mapping statuses to
	# arrayrefs containing abbreviations
	my %statuses = reverse_hash(%abbrevs);
	
	# look at existing statuses to see if we can avoid adding some new ones
	my $i = retrieve_all WeBWorK::DBv3::Status;
	while (my $Status = $i->next) {
		if (exists $statuses{$Status->name}) {
			debug("Status '", $Status->name, "' (ID $Status) already exists in the database -- skipping.\n");
			# add entries mapping abbreviations to the ID of this status
			foreach my $abbrev (@{$statuses{$Status->name}}) {
				$abbrev_to_status_id{$abbrev} = $Status->id;
			}
			
			delete $statuses{$Status->name};
		}
	}
	
	if ($opt_s) {
		debug("Updating status table (as per -s switch).\n");
		foreach my $status (keys %statuses) {
			my %flags;
			%flags = %{ STATUS_MAP->{$status} } if exists STATUS_MAP->{$status};
			my $Status = create WeBWorK::DBv3::Status({name => $status, %flags});
			
			my @flags = grep { $flags{$_} } keys %flags;
			debug("Added status '", $Status->name, "' (ID $Status) with flags '@flags'.\n");
			
			# add entries mapping abbreviations to the ID of this status
			foreach my $abbrev (@{$statuses{$status}}) {
				$abbrev_to_status_id{$abbrev} = $Status->id;
			}
		}
	} else {
		debug("Not updating status table (as per lack of -s switch).\n");
		debug("I might run into users with status abbreviations that don't map to statuses later.\n");
	}
	
	return %abbrev_to_status_id;
}

################################################################################

sub copy_course_data {
	my ($courseID, $abbrev_to_status_id, $level_to_role_id) = @_;
	
	debug("Processing course '$courseID'...\n");
	
	my $course_ce = WeBWorK::CourseEnvironment->new({
		webwork_dir => $ENV{WEBWORK_ROOT},
		courseName => $courseID,
	});
	
	my $course_db = WeBWorK::DB->new($course_ce->{dbLayout});
	
	# First we see if this course already exists. If it does, there's a problem
	# and we throw an exception.
	if (search WeBWorK::DBv3::Course(name => $courseID)) {
		die "Course '$courseID' exists in v3 DB";
	}
	
	debug("Course '$courseID' doesn't exist in v3 DB -- adding.\n");
	my $v3Course = create WeBWorK::DBv3::Course({name => $courseID});
	
	copy_users($course_db, $v3Course, $abbrev_to_status_id, $level_to_role_id);
	
	copy_abstract_data($course_db, $v3Course);
}

################################################################################

sub copy_users {
	my ($course_db, $v3Course, $abbrev_to_status_id, $level_to_role_id) = @_;
	
	my $DefaultStatus = find_status(DEFAULT_STATUS, $abbrev_to_status_id);
	die "Default status '", DEFAULT_STATUS, "' does not correspond to any v3 status.\n"
		unless $DefaultStatus;
	
	my $DefaultRole = find_role(DEFAULT_PERMISSION_LEVEL, $level_to_role_id);
	die "Default permission level '", DEFAULT_PERMISSION_LEVEL, "' does not correspond to any v3 role.\n"
		unless $DefaultRole;
	
	my @userIDs = $course_db->listUsers;
	my %Users; @Users{@userIDs} = $course_db->getUsers(@userIDs);
	my %Passwords; @Passwords{@userIDs} = $course_db->getPasswords(@userIDs);
	my %PermissionLevels; @PermissionLevels{@userIDs} = $course_db->getPermissionLevels(@userIDs);
	
	foreach my $userID (keys %Users) {
		my $User = $Users{$userID};
		my $Password = $Passwords{$userID};
		my $PermissionLevel = $PermissionLevels{$userID};
		
		unless (defined $User) {
			debug("User record for user ID '$userID' not found -- skipping.\n");
			next;
		}
		
		debug("Processing user '$userID'...\n");
		
		# create/update user record
		my ($v3User) = search WeBWorK::DBv3::User(login_id => $userID);
		if ($v3User) {
			debug("A user with login_id '$userID' exists in v3 database -- ");
			if ($opt_u) {
				# password record might not exist (annoying...)
				my $password = defined $Password ? $Password->password : "";
				
				debug("updating (as per -u switch).\n");
				$v3User->first_name($User->first_name) unless is_empty($User->first_name);
				$v3User->last_name($User->first_name) unless is_empty($User->last_name);
				$v3User->email_address($User->email_address) unless is_empty($User->email_address);
				$v3User->student_id($User->student_id) unless is_empty($User->student_id);
				$v3User->password($password) unless is_empty($password);
				$v3User->update;
			} else {
				debug("not updating (as per lack of -u switch).\n");
			}
		} else {
			# password record might not exist (annoying...)
			my $password = defined $Password ? $Password->password : "";
			
			debug("No user with login_id '$userID' exists in v3 database -- adding.\n");
			$v3User = create WeBWorK::DBv3::User({
				first_name    => $User->first_name,
				last_name     => $User->last_name,
				email_address => $User->email_address,
				student_id    => $User->student_id,
				login_id      => $User->user_id,
				password      => $password,
			});
		}
		
		# get status
		my $v3Status = find_status($User->status, $abbrev_to_status_id);
		unless ($v3Status) {
			debug("Using default status '", $DefaultStatus->name, "'.\n");
			$v3Status = $DefaultStatus;
		}
		
		# get role
		my $level = defined $PermissionLevel ? $PermissionLevel->permission : "";
		my $v3Role = find_role($level, $level_to_role_id);
		unless ($v3Role) {
			debug("Using default role '", $DefaultRole->name, "'.\n");
			$v3Role = $DefaultRole;
		}
		
		# find/create section record
		my $section = $User->section;
		my $v3Section;
		if (is_empty($section)) {
			debug("This user has section '$section'.\n");
			($v3Section) = search WeBWorK::DBv3::Section(course => $v3Course, name => $section);
			if ($v3Section) {
				debug("This corresponds to existing section ID $v3Section in v3 database.\n");
			} else {
				debug("No corresponding section exists in v3 DB -- adding.\n");
				$v3Section = create WeBWorK::DBv3::Section({
					course => $v3Course,
					name   => $section,
				});
				debug("Added section '", $v3Section->name, "' (ID $v3Section).\n");
			}
		} else {
			debug("This user has no section.\n");
		}
		
		# find/create recitation record
		my $recitation = $User->recitation;
		my $v3Recitation;
		if (is_empty($recitation)) {
			debug("This user has recitation '$recitation'.\n");
 			($v3Recitation) = search WeBWorK::DBv3::Recitation(course => $v3Course, name => $User->recitation);
			if ($v3Recitation) {
				debug("This correponds to existing recitation ID $v3Recitation in v3 database.\n");
			} else {
				debug("No corresponding recitation exists in v3 DB -- adding.\n");
				$v3Recitation = create WeBWorK::DBv3::Recitation({
					course => $v3Course,
					name   => $User->recitation,
				});
				debug("Added recitation '", $v3Recitation->name, "' (ID $v3Recitation).\n");
			}
		} else {
			debug("This user has no recitation.\n");
		}
		
		# create participant record
		debug("Adding participant record for user '$userID'...");
		#my $sectionID = $v3Section->id if defined $v3Section;
		#my $recitationID = $v3Recitation->id if defined $v3Recitation;
		my $v3Participant = create WeBWorK::DBv3::Participant({
			course     => $v3Course,
			user       => $v3User,
			status     => $v3Status,
			role       => $v3Role,
			section    => $v3Section,
			recitation => $v3Recitation,
			comment    => $User->comment,
		});
		debug(" added participant ID $v3Participant.\n");
	}
}

sub find_status {
	my ($status, $abbrev_to_status_id) = @_;
	
	return if is_empty($status);
	
	my $v3Status_id = $abbrev_to_status_id->{$status};
	my $v3Status;
	if (defined $v3Status_id) {
		#debug("Status '$status' maps to v3 status ID '$v3Status_id'.\n");
		$v3Status = retrieve WeBWorK::DBv3::Status($v3Status_id);
	} else {
		#debug("Status '$status' doesn't map to any v3 status.\n");
	}
	
	return $v3Status;
}

sub find_role {
	my ($level, $level_to_role_id) = @_;
	
	return if is_empty($level);
	
	my $v3Role_id = $level_to_role_id->{$level};
	my $v3Role;
	if (defined $v3Role_id) {
		#debug("Permission level '$level' maps to v3 role ID '$v3Role_id'.\n");
		$v3Role = retrieve WeBWorK::DBv3::Role($v3Role_id);
	} else {
		#debug("Permission level '$level' doesn't map to any v3 role.\n");
	}
	
	return $v3Role;
}

################################################################################

sub copy_abstract_data {
	my ($course_db, $v3Course) = @_;
	
	my @globalSetIDs = $course_db->listGlobalSets;
	my %GlobalSets; @GlobalSets{@globalSetIDs} = $course_db->getGlobalSets(@globalSetIDs);
	
	foreach my $globalSetID (keys %GlobalSets) {
		my $GlobalSet = $GlobalSets{$globalSetID};
		
		unless (defined $GlobalSet) {
			debug("Global set record for global set ID '$globalSetID' not found -- skipping.\n");
			next;
		}
		
		debug("Processing global set '$globalSetID'...\n");
		
		# set up some fields that need setting up
		# (if the conditional is false, the variable is left undefined)
		
		# convert empty strings to undefined values
		my $set_header = $GlobalSet->set_header unless is_empty($GlobalSet->set_header);
		my $hardcopy_header = $GlobalSet->hardcopy_header unless is_empty($GlobalSet->hardcopy_header);
		
		# convert 
		my $open_date = DateTime->from_epoch(epoch => $GlobalSet->open_date);
		my $due_date = DateTime->from_epoch(epoch => $GlobalSet->due_date);
		my $answer_date = DateTime->from_epoch(epoch => $GlobalSet->answer_date);
		
		# create abstract_set record
		debug("Adding abstract_set record for global set '$globalSetID'...");
		my $v3AbsSet = create WeBWorK::DBv3::AbstractSet({
			course => $v3Course,
			name => $GlobalSet->set_id,
			set_header => $set_header,
			hardcopy_header => $hardcopy_header,
			open_date => $open_date,
			due_date => $due_date,
			answer_date => $answer_date,
			published => $GlobalSet->published,
		});
		debug(" added abstract_set ID '$v3AbsSet'.\n");
		
		my @globalProblemIDs = sort { $a <=> $b } $course_db->listGlobalProblems($globalSetID);
		warn "globalProblemIDs=@globalProblemIDs\n";
		my %GlobalProblems; @GlobalProblems{@globalProblemIDs}
			= $course_db->getGlobalProblems(map { [ $globalSetID, $_ ] } @globalProblemIDs);
		
		my @problem_order;
		
		foreach my $globalProblemID (@globalProblemIDs) {
			my $GlobalProblem = $GlobalProblems{$globalProblemID};
			
			unless (defined $GlobalProblem) {
				warn "Global problem record for global problem ID '$globalProblemID' in set ID '$globalSetID' not found -- skipping.\n";
				next;
			}
			
			debug("Processing global problem '$globalProblemID'...\n");
		
			# convert max_attempts of -1 to undef
			my $max_attempts_per_version = $GlobalProblem->max_attempts
				if $GlobalProblem->max_attempts >= 0;
			
			# create abstract_problem record
			debug("Adding abstract_set record for global problem '$globalProblemID'...");
			my $v3AbsProb = create WeBWorK::DBv3::AbstractProblem({
				abstract_set => $v3AbsSet,
				name => "Legacy problem $globalProblemID",
				source_type => "file",
				source_file => $GlobalProblem->source_file,
				weight => $GlobalProblem->value,
				max_attempts_per_version => $max_attempts_per_version,
				version_creation_interval => undef,
				versions_per_interval => 1,
				version_due_date_offset => undef,
				version_answer_date_offset => undef,
			});
			debug(" added abstract_problem ID '$v3AbsProb'.\n");
			
			push @problem_order, $v3AbsProb->id;
		}
		
		# update problem order
		debug("Setting problem order to: '@problem_order'...");
		$v3AbsSet->problem_order_list(@problem_order);
		$v3AbsSet->update;
		debug(" done.\n");
	}
}















