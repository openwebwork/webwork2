/*    Lets user reshape a graph by dragging points up and down.    Shift-click to move all points back to the vertical center.    Left click to drag a point and drag its neighbors along.    Right-click to drag a point without dragging its neighbors.    --David Eck, June 2000 (eck@hws.edu, http://math.hws.edu/eck/)*/import java.awt.*;import java.applet.Applet;import java.util.StringTokenizer;public class GummyGraph extends Applet {   // Parameters that can be set through appelt params and manipulated   // with JavaScript.  (See public methods below.)   private int points = 11;   private double xmin = -5, xmax = 5, ymin = -5, ymax = 5;   private double xGrid = 1;   private double yGrid = 1;   private int gap = 5;   private double fallOff = 0.5;      private Color borderColor = Color.black;   private int borderWidth = 2;   private Color gridColor = Color.lightGray;   private Color axesColor = new Color(0,0,220);   private Color lightAxesColor = new Color(160,180,255);   private Color graphColor = Color.magenta;   private boolean showPoints = true;   private boolean showGrid = true;   // Background color is set in init(); change it there.      //-------------------- private implementation details ---------------------------      private Image OSC = null;   private int canvasWidth, canvasHeight;   private boolean graphNeedsRedraw;   private boolean axesNeedsRedraw;   private boolean needsRedraw;      //------------------- Public methods for scripting -------------------------------      public int getPointCount() {        // Return the number of draggable points on the graph        // (which is one plus the number of sub-intervals).      return points;   }      public double getX(int pointNumber) {        // Get the x-value of point number pointNumber.        // Note: x-values are always evenly spaced.      if (pointNumber < 0 || pointNumber >= points)         return Double.NaN;      return xmin + pointNumber*(xmax-xmin)/(points-1);   }      public double getY(int pointNumber) {        // Return the y-value of point number pointNumber.        // X and y values are stored internally as values        // between 0 and 1.  The actual x and y values        // are determined by scaling these internal values        // using the current xmin, xmax, ymin, ymax.      if (pointNumber < 0 || pointNumber >= points)         return Double.NaN;      return ymin + yValues[pointNumber]*(ymax - ymin);   }      public double getDerivative(int pointNumber) {        // Get the derivative at point number pointNumber.        // This is just computed from the y-values.      if (pointNumber < 0 || pointNumber >= points)         return Double.NaN;      double dx = 1.0/points * (xmax - xmin);      if (pointNumber == 0)         return (yValues[1] - yValues[0])*(ymax-ymin)/dx;      else if (pointNumber == points-1)         return (yValues[points-1] - yValues[points-2])*(ymax-ymin)/dx;      else         return (yValues[pointNumber+1] - yValues[pointNumber-1])*(ymax-ymin)/(2*dx);   }      public void reset() {        // Puts all points back to the vertical center of the applet.      for (int i = 0; i < points; i++) {        yValues[i] = 0.5;        derivatives[i] = 0;      }      graphNeedsRedraw = true;      repaint();   }      public void setPointCount(int ct) {        // Set the number of points and reset y-values        // to the vertical center of the applet.      if (ct > 2 && ct <= 500) {         points = ct;         yValues = new double[points];         derivatives = new double[points];         for (int i = 0; i < points; i++)            yValues[i] = 0.5;         graphNeedsRedraw = true;         repaint();      }   }      public void setY(int pointNumber, double val) {        // Change the y-value of one point.      if (pointNumber < 0 || pointNumber >= 0 || val < ymin || val > ymax)         return;      yValues[pointNumber] = (val-ymin)/(ymax-ymin);      graphNeedsRedraw = true;      repaint();   }      public boolean setPoints(String points) {         // The string, points, should be a list of numbers         // separated by spaces or commas.  These are used as         // y-values for the points on the curve, replacing the         // current points.  Values are clamped to the range         // from ymin to ymax.  If the contents of the string         // are not legal, the current graph is not changed         // and the value false is returned.  If the contents         // of points are legal, true is returned.      double[] vals = getDoubles(points);      if (vals == null || vals.length < 3 || vals.length > 500)         return false;      setPointCount(vals.length);  // Sets graphNeedsRedraw = true and calls repaint()      for (int i = 0; i < vals.length; i++) {         if (vals[i] > ymax)            yValues[i] = 1;         else if (vals[i] < ymin)            yValues[i] = 0;         else            yValues[i] = (vals[i]-ymin)/(ymax-ymin);      }      makeDerivs();      return true;   }      public void setLimits(double xmin, double xmax, double ymin, double ymax) {          // Change the ranges of x and y on the applet.      if (xmax <= xmin || ymax <= ymin)         return;      this.ymax = ymax;      this.ymin = ymin;      this.xmax = xmax;      this.xmin = xmin;      axesNeedsRedraw = true;      repaint();   }      public void setGap(int g) {         // This is space left between the axex and the border          // of the applet.  Default is 5.      if (g >= 0 && g != gap) {         gap = g;         axesNeedsRedraw = true;         graphNeedsRedraw = true;         repaint();      }   }      public void setXGrid(double spacing) {         // Set spacing between x grid lines (in the same units         // that are used for xmin and xmax, so changing these         // will change the number of grid lines).  If the         // value is zero, no x grid lines are drawn.      if (spacing >= 0) {         xGrid = spacing;         needsRedraw = true;         repaint();      }   }      public void setYGrid(double spacing) {        // Set spacing between y grid lines.  If the value is        // zero, no y grid lines are drawn.      if (spacing >= 0) {         yGrid = spacing;         needsRedraw = true;         repaint();      }   }      public void setFallOff(double factor) {        // When a point is dragged with the left mouse button, it can drag        // its neighbors along.  The displacement of the neighbor is        // less than the displacement of the point by the fallOff factor.        // For the neighbor of the neighbor, the displacement decreases by        // another fallOff factor, and so on.  If the value is zero,        // then neighbors are not dragged at all.  If the number of points        // is small, this should be close to zero.  For large numbers of        // points, it can be close to one.      if (factor >= 0 && factor < 1) {         fallOff = factor;      }   }      public void setBorderWidth(int b) {         // How many pixels is the border drawn around the edge of the         // applet.      if (b >= 0) {         borderWidth = b;         needsRedraw = true;         repaint();      }   }      public void setBorderColor(String color) {         // Color of border.      Color c = getColor(color);      if (c != null) {         borderColor = c;         needsRedraw = true;         repaint();      }   }      public void setGridColor(String color) {         // Color of grid lines.      Color c = getColor(color);      if (c != null) {         gridColor = c;         needsRedraw = true;         repaint();      }   }      public void setAxesColor(String color) {         // Color of axes.      Color c = getColor(color);      if (c != null) {         axesColor= c;         needsRedraw = true;         repaint();      }   }      public void setLightAxesColor(String color) {         // Color used for axis when the real axis is         // outside of the applet.      Color c = getColor(color);      if (c != null) {         lightAxesColor= c;         needsRedraw = true;         repaint();      }   }      public void setGraphColor(String color) {        // Color of graph.      Color c = getColor(color);      if (c != null) {         graphColor= c;         needsRedraw = true;         repaint();      }   }      public void setBackgroundColor(String color) {        // Background color for the whole applet.      Color c = getColor(color);      if (c != null) {         setBackground(c);         needsRedraw = true;         repaint();      }   }      public void setShowPoints(boolean show) {        // Should the points be drawn as little circles?        // If you have a lot of points, it might not be        // a good idea, since then just about any point on        // the graph can be dragged.      if (show != showPoints) {         showPoints = show;         needsRedraw = true;         repaint();      }   }         public void setShowGrid(boolean show) {         // Should the grid lines be drawn?      if (show != showGrid) {         showGrid = show;         needsRedraw = true;         repaint();      }   }         //----------------- Init method can set properties from applet params ---------------      public void init() {      setBackground(Color.white);      setBackgroundColor(getParameter("backgroundColor"));      setBorderColor(getParameter("borderColor"));      setAxesColor(getParameter("axesColor"));      setLightAxesColor(getParameter("lightAxesColor"));      setGraphColor(getParameter("graphColor"));      setGridColor(getParameter("gridColor"));      setGap(getInt(getParameter("gap")));      int n = getInt(getParameter("pointCount"));      setPointCount( (n > 2 && n <= 500)? n : 11 );      double[] dvals = getDoubles(getParameter("limits"));      if (dvals != null && dvals.length == 4)         setLimits(dvals[0], dvals[1], dvals[2], dvals[3]);      setXGrid(getDouble(getParameter("xGrid")));      setYGrid(getDouble(getParameter("yGrid")));      setFallOff(getDouble(getParameter("fallOff")));      setBorderWidth(getInt(getParameter("borderWidth")));      if ("no".equalsIgnoreCase(getParameter("showPoints")))         showPoints = false;      if ("no".equalsIgnoreCase(getParameter("showGrid")))         showGrid = false;      setPoints(getParameter("points"));  // overrides point count   }      //----------------------- For getting values from strings -------------------------      private int getInt(String str) {      if (str == null || str.trim().length() == 0)         return Integer.MIN_VALUE;      try {         return Integer.parseInt(str);      }      catch (NumberFormatException e) {         return Integer.MIN_VALUE;      }   }      private int[] getInts(String str) {      if (str == null)         return null;      StringTokenizer tk = new StringTokenizer(str," ,\t");      int ct = tk.countTokens();      if (ct == 0)         return null;      int[] vals = new int[ct];      for (int i = 0; i < ct; i++) {         String s = tk.nextToken();         vals[i] = getInt(s);         if (vals[i] == Integer.MIN_VALUE)            return null;      }      return null;   }      private double getDouble(String str) {      if (str == null || str.trim().length() == 0)         return Double.NaN;      try {         return (new Double(str)).doubleValue();      }      catch (NumberFormatException e) {         return Double.NaN;      }   }      private double[] getDoubles(String str) {      if (str == null)         return null;      StringTokenizer tk = new StringTokenizer(str," ,\t");      int ct = tk.countTokens();      if (ct == 0)         return null;      double[] vals = new double[ct];      for (int i = 0; i < ct; i++) {         String s = tk.nextToken();         vals[i] = getDouble(s);         if (Double.isNaN(vals[i]) || Double.isInfinite(vals[i]))            return null;      }      return vals;   }      private static String[] colorNames = {         "black", "white", "red", "green", "blue",         "yellow", "cyan", "magenta", "pink", "orange",         "lightGray", "gray", "darkGray"      };   private static Color[] colorList = {         Color.black, Color.white, Color.red, Color.green, Color.blue,         Color.yellow, Color.cyan, Color.magenta, Color.pink, Color.orange,         Color.lightGray, Color.gray, Color.darkGray      };      private Color getColor(String str) {      if (str == null)         return null;      str = str.trim();      if (str.length() == 0)         return null;      if (Character.isDigit(str.charAt(1))) {         int[] levels = getInts(str);         if (levels == null || levels.length != 3)            return null;         if (levels[0] < 0 || levels[0] > 255 || levels[1] < 0 || levels[1] > 255 || levels[2] < 0 || levels[2] > 255)            return null;         return new Color(levels[0],levels[1],levels[2]);      }      else {         for (int i = 0; i < colorNames.length; i++)            if (colorNames[i].equalsIgnoreCase(str))               return colorList[i];         return null;      }   }      public void update(Graphics g) {      paint(g);   }      //--------------------------------------------------------------------------      synchronized public void paint(Graphics g) {      int width = size().width;      int height = size().height;      if (OSC == null || width != canvasWidth || height != canvasHeight) {         axesNeedsRedraw = true;         graphNeedsRedraw = true;         canvasWidth = width;         canvasHeight = height;         OSC = null;         try {            OSC = createImage(width,height);         }         catch (OutOfMemoryError e) {         }      }      if (OSC == null) {         draw(g);      }      else {         if (axesNeedsRedraw || graphNeedsRedraw || needsRedraw) {            Graphics OSG = OSC.getGraphics();            draw(OSG);            OSG.dispose();            needsRedraw = false;         }         g.drawImage(OSC,0,0,this);      }   }      private void draw(Graphics g) {      g.setColor(getBackground());      g.fillRect(0,0,canvasWidth,canvasHeight);      drawGrid(g);      g.setColor(borderColor);      for (int i = 0; i < borderWidth; i++)         g.drawRect(i, i, canvasWidth - 2*i - 1, canvasHeight - 2*i - 1);      drawAxes(g);      drawGraph(g);   }      private void drawGrid(Graphics g) {      if (!showGrid)         return;      g.setColor(gridColor);      if (xGrid > 0) {         double x = (int)(xmin/xGrid)*xGrid;         while (x <= xmax) {            int a = (int)(gap + (x-xmin)*(canvasWidth-2*gap)/(xmax - xmin));            g.drawLine(a,0,a,canvasHeight);            x += xGrid;         }      }      if (yGrid > 0) {         double y = (int)(ymin/yGrid)*yGrid;         while (y <= ymax) {            int b = (int)(gap + (ymax-y)*(canvasHeight-2*gap)/(ymax - ymin));            g.drawLine(0,b,canvasWidth,b);            y += yGrid;         }      }   }      //--------------------------- Axes ---------------------------------------      private int[] xTicks;   private int[] yTicks;   private String[] xTickLabels;   private String[] yTickLabels;   private int[][] xTickLabelPos;   private int[][] yTickLabelPos;   private int xAxisPixelPosition, yAxisPixelPosition;   private Font font;   private int ascent, descent, digitWidth;      private void drawAxes(Graphics g) {      if (axesNeedsRedraw) {         font = g.getFont();         FontMetrics fm = g.getFontMetrics(font);         setup(fm, xmin, xmax, ymin, ymax, 0, 0, canvasWidth, canvasHeight, gap);         axesNeedsRedraw = false;      }      if (ymax < 0 || ymin > 0)         g.setColor(lightAxesColor);      else          g.setColor(axesColor);      g.drawLine(gap, xAxisPixelPosition, canvasWidth - gap - 1, xAxisPixelPosition);      for (int i = 0; i < xTicks.length; i++) {         int a = (xAxisPixelPosition - 2 < 0) ? xAxisPixelPosition : xAxisPixelPosition - 2;         int b = (xAxisPixelPosition + 2 >= canvasHeight)? xAxisPixelPosition : xAxisPixelPosition + 2;          g.drawLine(xTicks[i], a, xTicks[i], b);      }      for (int i = 0; i < xTickLabels.length; i++)         g.drawString(xTickLabels[i], xTickLabelPos[i][0], xTickLabelPos[i][1]);      if (xmax < 0 || xmin > 0)         g.setColor(lightAxesColor);      else          g.setColor(axesColor);      g.drawLine(yAxisPixelPosition, gap, yAxisPixelPosition, canvasHeight - gap - 1);      for (int i = 0; i < yTicks.length; i++) {         int a = (yAxisPixelPosition - 2 < 0) ? yAxisPixelPosition : yAxisPixelPosition - 2;         int b = (yAxisPixelPosition + 2 >= canvasWidth)? yAxisPixelPosition : yAxisPixelPosition + 2;          g.drawLine(a, yTicks[i], b, yTicks[i]);      }      for (int i = 0; i < yTickLabels.length; i++)         g.drawString(yTickLabels[i], yTickLabelPos[i][0], yTickLabelPos[i][1]);   }      void setup(FontMetrics fm, double xmin, double xmax, double ymin, double ymax,                              int left, int top, int width, int height, int gap) {      digitWidth = fm.charWidth('0');      ascent = fm.getAscent();      descent = fm.getDescent();      if (ymax < 0)         xAxisPixelPosition = top + gap;      else if (ymin > 0)         xAxisPixelPosition = top + height - gap - 1;      else         xAxisPixelPosition = top + gap + (int)((height-2*gap - 1) * ymax / (ymax-ymin));      if (xmax < 0)         yAxisPixelPosition = left + width - gap - 1;      else if (xmin > 0)         yAxisPixelPosition = left + gap;      else         yAxisPixelPosition = left + gap - (int)((width-2*gap - 1) * xmin / (xmax-xmin));      double start = fudgeStart( ((xmax-xmin)*(yAxisPixelPosition - (left + gap)))/(width - 2*gap)  + xmin,                                                   0.05*(xmax-xmin) );      int labelCt = (width - 2*gap) / (8*digitWidth);      if (labelCt <= 2)         labelCt = 3;      else if (labelCt > 20)         labelCt = 20;      double interval = fudge( (xmax - xmin) / labelCt );      for (double mul = 1.5; mul < 4; mul += 0.5) {         if (fm.stringWidth(realToString(interval+start)) + digitWidth > (interval/(xmax-xmin))*(width-2*gap))  // overlapping labels             interval = fudge( mul*(xmax - xmin) / labelCt );         else            break;      }      double[] label = new double[50];      labelCt = 0;      double x = start + interval;      double limit = left + width;      while (labelCt < 50 && x < xmax) {         if (left + gap + (width-2*gap)*(x-xmin)/(xmax-xmin) + fm.stringWidth(realToString(x))/2 > limit)            break;         label[labelCt] = x;         labelCt++;         x += interval;      }      x = start - interval;      limit = left;      while (labelCt < 50 && x >= xmin) {         if (left + gap + (width-2*gap)*(x-xmin)/(xmax-xmin) - fm.stringWidth(realToString(x))/2 < limit)            break;         label[labelCt] = x;         labelCt++;         x -= interval;      }      xTicks = new int[labelCt];      xTickLabels = new String[labelCt];      xTickLabelPos = new int[labelCt][2];      for (int i = 0; i < labelCt; i++) {         xTicks[i] = (int)(left + gap + (width-2*gap)*(label[i]-xmin)/(xmax-xmin));         xTickLabels[i] = realToString(label[i]);         xTickLabelPos[i][0] = xTicks[i] - fm.stringWidth(xTickLabels[i])/2;         if (xAxisPixelPosition - 4 - ascent >= top)            xTickLabelPos[i][1] = xAxisPixelPosition - 4;         else            xTickLabelPos[i][1] = xAxisPixelPosition + 4 + ascent;      }            start = fudgeStart( ymax - ((ymax-ymin)*(xAxisPixelPosition - (top + gap)))/(height - 2*gap),                                                   0.05*(ymax-ymin) );      labelCt = (height - 2*gap) / (4*(ascent+descent));      if (labelCt <= 2)         labelCt = 3;      else if (labelCt > 20)         labelCt = 20;      interval = fudge( (ymax - ymin) / labelCt );      labelCt = 0;      double y = start + interval;      limit = top + 8 + gap;      while (labelCt < 50 && y <= ymax) {         if (top + gap + (height-2*gap)*(ymax-y)/(ymax-ymin) - ascent/2 < limit)            break;         label[labelCt] = y;         labelCt++;         y += interval;      }      y = start - interval;      limit = top + height - gap - 8;      while (labelCt < 50 && y >= ymin) {         if (top + gap + (height-2*gap)*(ymax-y)/(ymax-ymin) + ascent/2 > limit)            break;         label[labelCt] = y;         labelCt++;         y -= interval;      }      yTicks = new int[labelCt];      yTickLabels = new String[labelCt];      yTickLabelPos = new int[labelCt][2];      int w = 0;  // max width of tick mark      for (int i = 0; i < labelCt; i++) {          yTickLabels[i] = realToString(label[i]);          int s = fm.stringWidth(yTickLabels[i]);          if (s > w)             w = s;        }      for (int i = 0; i < labelCt; i++) {         yTicks[i] = (int)(top + gap + (height-2*gap)*(ymax-label[i])/(ymax-ymin));         yTickLabelPos[i][1] = yTicks[i] + ascent/2;         if (yAxisPixelPosition - 4 - w < left)            yTickLabelPos[i][0] = yAxisPixelPosition + 4;         else            yTickLabelPos[i][0] = yAxisPixelPosition - 4 - fm.stringWidth(yTickLabels[i]);      }   } // end setup()            double fudge (double x) { // Translated directly from the Pascal version of xFunctions.                             // Move x to a more "rounded" value; used for labeling axes.      int i, digits;      double y;      if (Math.abs(x) < 0.0005 || Math.abs(x) > 500000)         return x;      else if (Math.abs(x) < 0.1 || Math.abs(x) > 5000) {            y = x;            digits = 0;            if (Math.abs(y) >= 1) {               while (Math.abs(y) >= 8.75) {                     y = y / 10;                     digits = digits + 1;               }            }            else {               while (Math.abs(y) < 1) {                     y = y * 10;                     digits = digits - 1;               }            }            y = Math.round(y * 4) / 4;            if (digits > 0) {               for (int j = 0; j < digits; j++)                  y = y * 10;            }            else if (digits < 0) {               for (int j = 0; j < -digits; j++)                  y = y / 10;            }            return y;      }      else if (Math.abs(x) < 0.5)         return Math.round(10 * x) / 10.0;      else if (Math.abs(x) < 2.5)         return Math.round(2 * x) / 2.0;      else if (Math.abs(x) < 12)         return Math.round(x);      else if (Math.abs(x) < 120)          return Math.round(x / 10) * 10.0;      else if (Math.abs(x) < 1200)         return Math.round(x / 100) * 100.0;      else         return Math.round(x / 1000) * 1000.0;   }         double fudgeStart(double a, double diff) { // Adapted from the Pascal version of xFunctions.                                              // Tries to find a "rounded value" withint diff of a      if (Math.abs(Math.round(a) - a) < diff)          return Math.round(a);      for (double x = 10; x <= 100000; x *= 10) {          double d = Math.round(a*x) / x;          if (Math.abs(d - a) < diff)             return d;      }      return a;   }   public static String realToString(double x) {      return realToString(x,8);   }      public static String realToString(double x, int width) {         // Goal is to return a reasonable string representation         // of x, using at most width spaces.  (If width is         // unreasonably big or small, its value is adjusted to         // lie in the range 7 to 25.)      width = Math.min(25, Math.max(7,width));      if (Double.isNaN(x))         return "undefined";      if (Double.isInfinite(x))         if (x < 0)            return "-INF";         else            return "INF";      String s = String.valueOf(x);      if (Math.rint(x) == x && Math.abs(x) < 5e15 && s.length() <= (width+2))         return String.valueOf( (long)x );  // return string without trailing ".0"      if (s.length() <= width)         return s;      boolean neg = false;      if (x < 0) {         neg = true;         x = -x;         width--;         s = String.valueOf(x);      }      long maxForNonExp = 5*(long)Math.pow(10,width-2);      if (x >= 0.0005 && x <= maxForNonExp && (s.indexOf('E') == -1 && s.indexOf('e') == -1)) {         s = round(s,width);         s = trimZeros(s);      }      else if (x > 1) { // construct exponential form with positive exponent          long power = (long)Math.floor(Math.log(x)/Math.log(10));          String exp = "E" + power;          int numlength = width - exp.length();          x = x / Math.pow(10,power);          s = String.valueOf(x);          s = round(s,numlength);          s = trimZeros(s);          s += exp;      }      else { // constuct exponential form with negative argument          long power = (long)Math.ceil(-Math.log(x)/Math.log(10));          String exp = "E-" + power;          int numlength = width - exp.length();          x = x * Math.pow(10,power);          s = String.valueOf(x);          s = round(s,numlength);          s = trimZeros(s);          s += exp;      }      if (neg)         return "-" + s;      else         return s;   }      private static String trimZeros(String num) {        // remove trailing zeros if num contains a decimal point, and        // remove the decimal point as well if all following digits are zero     if (num.indexOf('.') >= 0 && num.charAt(num.length() - 1) == '0') {        int i = num.length() - 1;        while (num.charAt(i) == '0')           i--;        if (num.charAt(i) == '.')           num = num.substring(0,i);        else           num = num.substring(0,i+1);     }     return num;   }      private static String round(String num, int length) {         // Round off num to the given field width      if (num.indexOf('.') < 0)         return num;      if (num.length() <= length)         return num;      if (num.charAt(length) >= '5' && num.charAt(length) != '.') {         char[] temp = new char[length+1];         int ct = length;         boolean rounding = true;         for (int i = length-1; i >= 0; i--) {            temp[ct] = num.charAt(i);             if (rounding && temp[ct] != '.') {               if (temp[ct] < '9') {                  temp[ct]++;                  rounding = false;               }               else                  temp[ct] = '0';            }            ct--;         }         if (rounding) {            temp[ct] = '1';            ct--;         }         // ct is -1 or 0         return new String(temp,ct+1,length-ct);      }      else          return num.substring(0,length);   }         //--------------------------- Graph --------------------------------------      private double[] yValues;   private double[] derivatives;      private int[] pixelX;   private int[] pixelY;   private int[] dotX;   private int[] dotY;      private void drawGraph(Graphics g) {      if (graphNeedsRedraw) {         makeGraphCoords();         graphNeedsRedraw = false;      }      g.setColor(graphColor);      for (int i = 1; i < pixelX.length; i++) {         g.drawLine(pixelX[i-1], pixelY[i-1], pixelX[i], pixelY[i]);      }      if (showPoints) {         for (int i = 0; i < dotX.length; i++)            g.fillOval(dotX[i], dotY[i], 5, 5);      }   }      private void makeGraphCoords() {      int pointCt = (canvasWidth-2*gap-2) / 3 + 2;      if (pixelX == null || pixelX.length != pointCt) {         pixelX = new int[pointCt];         for (int i = 0; i < pointCt - 1; i++)            pixelX[i] = gap + i*3;         pixelX[pointCt-1] = canvasWidth - gap - 1;         pixelY = new int[pointCt];      }      double dx = (xmax - xmin) / (canvasWidth - 2*gap - 1);      double dy = (ymax - ymin) / (canvasHeight - 2*gap - 1);      for (int i = 0; i < pointCt; i++) {         double x = xmin + dx*(pixelX[i]-gap);         double y = eval(x);         pixelY[i] = (int)(gap + (ymax - y)/dy);      }      if (dotX == null || dotX.length != points) {         dotX = new int[points];         dotY = new int[points];      }      dx = (xmax - xmin) / (points-1);      double factorX = (canvasWidth - 2*gap - 1)/(xmax-xmin);      double factorY = (canvasHeight - 2*gap - 1)/(ymax-ymin);      for (int i = 0; i < points; i++) {         double x = xmin + dx*i;         double y = eval(x);         dotX[i] = (int)(gap + (x-xmin)*factorX) - 2;         dotY[i] = (int)(gap + (ymax-y)*factorY) - 2;      }   }      private double eval(double x) {         // NOTE:  yvalues and derivatives are stored as if x and y range from 0 to 1!!!      double scaledx = (x-xmin)/(xmax-xmin);      int interval = (int)((points-1)*scaledx);      if (interval >= points-1)         return ymin + yValues[points-1]*(ymax-ymin);      double temp = 1.0/(points-1);      double a = yValues[interval+1]/(temp*temp*temp);      double b = derivatives[interval+1]/(temp*temp) - 3*a;      double d = -yValues[interval]/(temp*temp*temp);      double c = derivatives[interval]/(temp*temp) - 3*d;      double t1 = scaledx - interval*temp;      double t2 = t1*t1;      double t3 = t2*t1;      double s1 = scaledx - (interval+1)*temp;      double s2 = s1*s1;      double s3 = s2*s1;      double scaledy = a*t3 + b*t2*s1 + c*t1*s2 + d*s3;      return ymin + scaledy*(ymax-ymin);   }      //--------------------------- Mouse Handling -----------------------------   private boolean dragging;   private int dragPoint;   private int lastY;   private boolean propogate;      synchronized public boolean mouseDown(Event evt, int x, int y) {      dragging = false;      if (evt.shiftDown()) {         for (int i = 0; i < points; i++) {            yValues[i] = 0.5;            derivatives[i] = 0;         }         graphNeedsRedraw = true;         repaint();         return true;      }      if (dotX == null || graphNeedsRedraw) {  // shouldn't happen         repaint();         return true;      }      for (int i = 0; i < points; i++)        if (x >= dotX[i] - 1  && x < dotX[i] + 7 && y >= dotY[i] - 1 && y < dotY[i] + 7) {           dragging = true;           dragPoint = i;           lastY = y;           propogate = ! evt.metaDown();           break;        }      return true;   }      synchronized public boolean mouseUp(Event evt, int x, int y) {      dragging = false;      return true;   }      synchronized public boolean mouseDrag(Event evt, int x, int y) {      if (!dragging || graphNeedsRedraw)         return true;      if (y < gap)         y = gap;      if (y > canvasHeight - gap)         y = canvasHeight - gap;      if (y - lastY == 0)         return true;      movePoint(dragPoint, y - lastY);      lastY = y;      return true;   }      private void movePoint(int pointNum, int pixelsOffset) {      double offset = -1.0/(canvasHeight - 2*gap) * pixelsOffset;      double oldy = yValues[pointNum];      yValues[pointNum] += offset;      double dx = 1.0 / (points - 1);      if (propogate && fallOff > 0) {         if (offset > 0) {            int pt = pointNum + 1;            double factor = fallOff;            double prevy = oldy;            while (pt < points && yValues[pt] < prevy) {               prevy = yValues[pt];               yValues[pt] += offset*factor;               factor *= fallOff;               pt++;            }            pt = pointNum - 1;            factor = fallOff;            prevy = oldy;            while (pt >= 0 && yValues[pt] < prevy) {               prevy = yValues[pt];               yValues[pt] += offset*factor;               factor *= fallOff;               pt--;            }         }         else {            int pt = pointNum + 1;            double factor = fallOff;            double prevy = oldy;            while (pt < points && yValues[pt] > prevy) {               prevy = yValues[pt];               yValues[pt] += offset*factor;               factor *= fallOff;               pt++;            }            pt = pointNum - 1;            factor = fallOff;            prevy = oldy;            while (pt >= 0 && yValues[pt] > prevy) {               prevy = yValues[pt];               yValues[pt] += offset*factor;               factor *= fallOff;               pt--;            }         }      }      graphNeedsRedraw = true;      makeDerivs();      repaint();   }   private void makeDerivs() {      double dx = 1.0 / (points - 1);      derivatives[0] = (yValues[1] - yValues[0])/dx;      for (int i = 1; i < points - 1; i++)         derivatives[i] = (yValues[i+1] - yValues[i-1])/(2*dx);      derivatives[points-1] = (yValues[points-1] - yValues[points-2])/dx;   }} // end class GummyGraph